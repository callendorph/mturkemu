# File: mturk/handlers.py
# Author: Skeleton Autogenerated by CreateMTurkViews.py script
#
# Description:
#    This file contains the skeleton of all methods that need to be
# implemented for the MTurk mock.
#
#

from django.shortcuts import get_object_or_404
from django.core.exceptions import PermissionDenied
from django.http import Http404
from django.utils import timezone

from mturk.models import *
from mturk.taskviews import CreateTaskType, CreateTask
from mturk.errors import *
from mturk.questions import QuestionValidator
from mturk.fields import *

from datetime import timedelta

class MTurkHandlers(object):

    #######################
    # API Methods
    #######################

    def ApproveAssignment(self, **kwargs):
        requester = kwargs["EmuRequester"]
        assignId = kwargs["AssignmentId"]
        try:
            overrideReject = kwargs["OverrideRejection"]
        except KeyError:
            overrideReject = False

        assign = get_object_or_404(
            Assignment,
            aws_id = assignId
            )

        if ( assign.task.requester != requester ):
            raise PermissionDenied()

        if ( assign.is_accepted()):
            raise RequestError("Assignment Not Ready for Decision Yet",15)

        if ( assign.is_rejected() and not overrideReject ):
            raise RequestError("Cannot override previous Rejection", 16)

        if ( assign.is_approved() ):
            # @note - check what AWS actually does here
            raise RequestError("Assignment already Approved", 17)

        assign.status = AssignmentStatusField.APPROVED
        assign.approved = timezone.now()

        try:
            feedback = kwargs["RequesterFeedback"]
            assign.feedback = feedback
        except KeyError:
            pass

        assign.save()

        return({})

    def ListWorkersWithQualificationType(self, **kwargs):
        pass

    def ListAssignmentsForHIT(self, **kwargs):
        pass

    def ListWorkerBlocks(self, **kwargs):
        pass

    def CreateAdditionalAssignmentsForHIT(self, **kwargs):
        requester = kwargs["EmuRequester"]
        taskId = kwargs["HITId"]
        addAssigns = kwargs["NumberOfAdditionalAssignments"]

        task = get_object_or_404(Task, aws_id = taskId)
        if ( task.requester != requester ):
            raise PermissionDenied()

        newAssignsCount = task.max_assignments + addAssigns
        if ( task.max_assignments < 10 and newAssignCount >= 10 ):
            raise RequestError("InvalidMaximumAssignmentsIncrease",17)

        task.max_assignments = newAssignsCount
        try:
            unique = kwargs["UniqueRequestToken"]
            if ( len(unique) > 0 ):
                if ( task.unique == unique ):
                    # @note - No SAVE Op called yet so max_assignments
                    # will revert
                    raise RequestError("Duplicate Unique Token", 19)
            task.unique = unique
        except KeyError:
            pass

        task.save()

        return({})

    def CreateWorkerBlock(self, **kwargs):
        requester = kwargs["EmuRequester"]
        workerId = kwargs["WorkerId"]
        worker = get_object_or_404(
            Worker,
            aws_id = workerId
            )

        try:
            block = WorkerBlock.objects.get(
                worker = worker,
                requester = requester
                )
        except WorkerBlock.DoesNotExist:
            block = WorkerBlock.objects.create(
                worker = worker,
                requester = requester
                )
        block.active = True
        try:
            reason = kwargs["Reason"]
            block.reason = reason
        except KeyError:
            pass
        block.save()
        return({})

    def GetQualificationScore(self, **kwargs):
        requester = kwargs["EmuRequester"]
        qualId = kwargs["QualificationId"]
        workerId = kwargs["WorkerId"]

        qual = get_object_or_404(Qualification, aws_id = qualId)
        if ( qual.requester != requester ):
            raise PermissionDenied()

        try:
            qualGrant = QualificationGrant.objects.get(
                worker__aws_id = workerId,
                qualification = qual
            )
        except QualificationGrant.DoesNotExist:
            raise Http404()

        return({
            "Qualification" : qualGrant.serialize()
            })


    def UpdateHITTypeOfHIT(self, **kwargs):
        # @note - I'm not totally sure how this
        #    method should be implemented - very low
        #    on details in the docs
        #
        # Need to do some experimentation in the
        # sandbox to determine functionality.
        raise NotImplementedError("Confusing Docs")

    def NotifyWorkers(self, **kwargs):
        raise NotImplementedError("No Notifications Yet")

    def ListQualificationTypes(self, **kwargs):
        pass

    def UpdateHITReviewStatus(self, **kwargs):
        requester = kwargs["EmuRequester"]
        taskId = kwargs["HITId"]
        revert = kwargs.get("Revert", False)

        task = get_object_or_404(Task, aws_id = taskId)
        if ( task.requester != requester ):
            raise PermissionDenied()

        if ( task.is_reviewable() ):
            task.state = TaskStatusField.REVIEWING
        elif ( task.is_reviewing() and revert ):
            task.state = TaskStatusField.REVIEWABLE

        task.save()

        return({})

    def CreateHITWithHITType(self, **kwargs):
        requester = kwargs["EmuRequester"]
        typeId = kwargs["HITTypeId"]

        taskType = get_object_or_404(
            TaskType,
            requester = requester,
            aws_id = typeId
            )

        proc = CreateTask(kwargs)
        task = proc.create(taskType = taskType)

        return({
            "HIT": task.serialize()
        })


    def DeleteHIT(self, **kwargs):
        requester = kwargs["EmuRequester"]
        HITId = kwargs["HITId"]
        task = Task.objects.get(requester = requester, aws_id = HITId)
        # This may be too harsh - perhaps we want to transition to
        # disposed state instead ? Might allow us to keep data
        # for testing and diagnostics
        task.dispose = True
        task.save()
        return({})

    def CreateQualificationType(self, **kwargs):
        requester = kwargs["EmuRequester"]

        name = kwargs["Name"]
        try:
            qual = Qualification.objects.get(
                requester = requester,
                name=name,
                dispose=False,
            )
            raise RequestError("Name is Not Unique", 1)
        except Qualification.DoesNotExist:
            pass

        createParams = {
            "requester" : requester,
            "name": name,
            "description" : kwargs["Description"],
        }

        status = kwargs["QualificationTypeStatus"]
        createParams["active"] = (status == "Active")

        try:
            retry_delay = int(kwargs["RetryDelayInSeconds"])
            createParams["retry_active"] = True
            createParams["retry_delay"] = timedelta(seconds=retry_delay)
        except KeyError:
            createParams["retry_active"] = False

        q = QuestionValidator()
        try:
            test = kwargs["Test"]
            if ( len(test) > 65535 ):
                raise RequestError("Invalid Test QuestionForm: Too Long", 2)
            if ( "TestDurationInSeconds" not in kwargs):
                raise RequestError(
                    "Missing required argument 'TestDurationInSeconds'", 3
                )
            testDuration = int(kwargs["TestDurationInSeconds"])
            if ( "AutoGranted" in kwargs ):
                if ( kwargs["AutoGranted"] ):
                    raise RequestError(
                        "Qualification cannot have AutoGranted 'True' and have a Test QuestionForm", 5
                    )

            name = q.determine_type(test)
            if ( name not in ["QuestionForm"]):
                raise RequestError(
                    "Invalid 'QuestionForm' object in 'Test' Parameter",10
                    )
            q.validate(name, test)
            createParams["test"] = test
            createParams["test_duration"] = timedelta(seconds=testDuration)
        except KeyError:
            pass

        try:
            answerKey = kwargs["AnswerKey"]
            if ( len(answerKey) > 65535 ):
                raise RequestError("Invalid AnswerKey: Too Long", 4)

            name = q.determine_type(answerKey)
            if ( name not in ["AnswerKey"]):
                raise RequestError("Invalid object in 'AnswerKey' Parameter", 11)
            q.validate(name, answerKey)
            createParams["answer"] = answerKey

        except KeyError:
            # Not required even with a test - just means requester
            # must manually accept.
            pass

        try:
            autoGranted = kwargs["AutoGranted"]
            createParams["auto_grant"] = autoGranted
            try:
                autoGrantValue = int(kwargs["AutoGrantedValue"])
                createParams["auto_grant_value"] = autoGrantValue
            except KeyError:
                pass
        except KeyError:
            pass


        qual = Qualification.objects.create(**createParams)
        qual.save()

        resp = {
           "QualificationType" : qual.serialize()
        }
        return(resp)

    def GetFileUploadURL(self, **kwargs):
        raise NotImplementedError("File Upload Not Implemented Yet")

    def ListQualificationRequests(self, **kwargs):
        pass

    def GetHIT(self, **kwargs):
        HITId = kwargs["HITId"]
        task = get_object_or_404(Task, aws_id = HITId)

        return({
            "HIT" : task.serialize()
            })

    def SendTestEventNotification(self, **kwargs):
        # @note - Not Implementing Notifications Yet
        raise NotImplementedError()


    def DeleteWorkerBlock(self, **kwargs):
        requester = kwargs["EmuRequester"]
        workerId = kwargs["WorkerId"]

        worker = get_object_or_404(
            Worker,
            aws_id = workerId
            )

        try:
            block = WorkerBlock.objects.get(
                worker = worker,
                requester = requester
                )
            block.active = False
            try:
                reason = kwargs["Reason"]
                block.reason = reason
            except KeyError:
                pass
            block.save()

        except WorkerBlock.DoesNotExist:
            pass

        return({})


    def CreateHITType(self, **kwargs):

        proc = CreateTaskType(kwargs)

        try:
            tt = proc.find_existing()
        except:
            tt = proc.create()

        return({
            "HITTypeId" : tt.aws_id,
        })


    def RejectAssignment(self, **kwargs):
        requester = kwargs["EmuRequester"]
        assignId = kwargs["AssignmentId"]

        assign = get_object_or_404(
            Assignment,
            aws_id = assignId
            )

        if ( assign.task.requester != requester ):
            raise PermissionDenied()

        if ( not assign.is_submitted() ):
            RequestError("Assignment Not Submitted", 14)

        assign.status = AssignmntStatusField.REJECTED
        assign.rejected = timezone.now()
        try:
            feedback = kwargs["RequesterFeedback"]
            assign.feedback = feedback
        except KeyError:
            pass

        assign.save()

        return({})

    def ListReviewableHITs(self, **kwargs):
        pass

    def ListHITs(self, **kwargs):
        pass

    def UpdateExpirationForHIT(self, **kwargs):
        requester = kwargs["EmuRequester"]

        taskId = kwargs["HITId"]
        expireAt = kwargs["ExpireAt"]

        task = get_object_or_404(Task, aws_id = taskId)
        if ( task.requester != requester ):
            raise PermissionDenied()

        currTime = timezone.now()
        if ( expireAt < currTime ):
            # Immediately Expire the Task
            # @todo - I need to test this on the sandbox
            #   to confirm this is the right behavior
            task.state = TaskStatusField.UNASSIGNABLE
        else:
            task.expires = expireAt

        task.save()
        return({})


    def RejectQualificationRequest(self, **kwargs):
        requester = kwargs["EmuRequester"]
        reqId = kwargs["QualificationRequestId"]

        req = get_object_or_404(
            QualificationRequester,
            aws_id = reqId
            )

        if ( req.qualification.requester != requester ):
            raise PermissionDenied()

        if ( not req.is_pending() ):
            # @todo - check if the server responds like this when
            #    the request is idle or already approved/rejected
            raise RequestError("Invalid Qualification State", 20)

        req.state = QualReqStatusField.REJECTED
        req.reason = kwargs.get("Reason", "")

        req.save()

        return({})

    def AssociateQualificationWithWorker(self, **kwargs):
        requester = kwargs["EmuRequester"]
        qualId = kwargs["QualificationTypeId"]
        workerId = kwargs["WorkerId"]

        try:
            value = kwargs["IntegerValue"]
        except KeyError:
            value = 1

        try:
            sendNotif = kwargs["SendNotification"]
            if ( sendNotif ):
                logger.warn("SendNotification = True: Not Implemented Yet")
        except KeyError:
            sendNotif = False

        qual = get_object_or_404(
            Qualification,
            requester = requester,
            aws_id = qualId
            )

        worker = get_object_or_404(Worker, aws_id = workerId)

        # First check if a worker qualification grant already exists
        try:
            grant = QualificationGrant.objects.get(
                worker = worker,
                qualification = qualification,
                )
            grant.value = value
            grant.active = True
        except QualificationGrant.DoesNotExist:
            grant = QualificationGrant.objects.create(
                worker = worker,
                qualification = qualification,
                value = value
                )

        grant.save()

        return({})


    def UpdateQualificationType(self, **kwargs):
        requester = kwargs["EmuRequester"]
        qualId = kwargs["QualificationTypeId"]

        qual = get_object_or_404(Qualification, aws_id = qualId)
        if ( qual.requester != requester ):
            raise PermissionDenied()

        # @todo Update parameters of the Qualification based on
        # available data
        try:
            desc = kwargs["Description"]
            if ( len(desc) > 0 ):
                qual.description = desc
        except KeyError:
            pass

        try:
            stat = kwargs["QualificationTypeStatus"]
            qual.active = ( stat == "Active" )
        except KeyError:
            pass


        try:
            retry = kwargs["RetryDelayInSeconds"]
            # @todo - handle me
        except KeyError:
            pass

        # Need to check create qual type because I think there is
        # some code that can be reused.
        #Test='string',
        #AnswerKey='string',
        #TestDurationInSeconds=123,
        #AutoGranted=True|False,
        #AutoGrantedValue=123

        return({
            "QualificationType": qual.serialize()
        })

    def GetAccountBalance(self, **kwargs):
        requester = kwargs["EmuRequester"]

        return({
            "AvailableBalance" : requester.get_balance()
            })

    def SendBonus(self, **kwargs):
        requester = kwargs["EmuRequester"]
        workerId = kwargs["WorkerId"]
        assignId = kwargs["AssignmentId"]

        worker = get_object_or_404(Worker, aws_id = workerId)
        assign = get_object_or_404(Assignment, aws_id = assignId)

        if ( assign.worker != worker or assign.task.requester != requester):
            raise PermissionDenied()

        createParams = {
            "worker" : worker,
            "assignment" : assign,
            }

        try:
            reason = kwargs["Reason"]
            createParams["reason"] = reason
        except KeyError:
            pass

        try:
            unique = kwargs["UniqueRequestToken"]
            if ( len(unique) > 0 ):
                hasExisting = BonusPayment.objects.filter(
                    worker = worker,
                    assignment = assign,
                    unique = unique
                ).exists()

                if ( hasExisting ):
                    raise RequestError(
                        "Duplicate UniqueRequestToken: %s" % unique,13
                    )
            createParams["unique"] = unique
        except KeyError:
            pass

        amount = float(kwargs["BonusAmount"])
        if ( requester.balance < amount ):
            raise RequestError("Requester Insufficient Funds", 14)

        createParam["amount"] = amount

        bp = BonusPayment.objects.create(**createParams)
        bp.save()

        return({})

    def GetAssignment(self, **kwargs):
        requester = kwargs["EmuRequester"]
        assignId = kwargs["AssignmentId"]

        assign = get_object_or_404(Assignment, aws_id = assignId)

        if ( assign.requester.id != requester.id ):
            raise PermissionDenied()

        ret = {
            "Assignment" : assign.serialize(),
            "HIT" : assign.task.serialize(),
        }
        return(ret)

    def DeleteQualificationType(self, **kwargs):
        requester = kwargs["EmuRequester"]
        qualId = kwargs["QualificationTypeId"]

        q = get_object_or_404(
            Qualification,
            requester = requester,
            aws_id = qualId
            )

        q.active = False
        q.dispose = True
        q.save()

        # @todo - We should do some queries to see if we
        #    can delete this qualification for realz
        #    For now, it will just be left so that any
        #    active Tasks, etc can't continue to reference it.

        return({})


    def CreateHIT(self, **kwargs):

        proc = CreateTask(kwargs)
        task = proc.create()

        return({
            "HIT": task.serialize()
        })

    def ListBonusPayments(self, **kwargs):
        requester = kwargs["EmuRequester"]

        # @note - I'm not totally sure how this method responds
        #   are HITId and AssignmentId mutually exclusive ?
        # Need to test on sandbox
        raise NotImplementedError()

    def UpdateNotificationSettings(self, **kwargs):
        raise NotImplementedError("No Notifications Yet")

    def DisassociateQualificationFromWorker(self, **kwargs):
        requester = kwargs["EmuRequester"]
        workerId = kwargs["WorkerId"]
        qualid = kwargs["QualificationTypeId"]

        worker = get_object_or_404(Worker, aws_id = workerId)
        qual = get_object_or_404(Qualification, aws_id = qualId)

        if ( qual.requester != requester ):
            raise PermissionDenied()

        grant = get_object_or_404(
            QualificationGrant,
            worker = worker,
            qualification = qual
            )

        # @todo - check how AWS responds if the grant
        #   has already been revoked.
        if ( grant.active ):
            grant.active = False

            try:
                reason = kwargs["Reason"]
                grant.reason = reason
            except KeyError:
                pass
            grant.save()

        return({})

    def GetQualificationType(self, **kwargs):
        qualId = kwargs["QualificationTypeId"]

        qual = get_object_or_404(Qualification, aws_id = qualId)
        return({
            "QualificationType": qual.serialize()
        })

    def AcceptQualificationRequest(self, **kwargs):
        requester = kwargs["EmuRequester"]
        reqId = kwargs["QualificationRequestId"]
        value = kwargs["IntegerValue"]

        req = get_object_or_404(QualificationRequest, aws_id = reqId)

        if ( req.qualification.requester != requester ):
            raise PermissionDenied()

        if ( req.state != QualReqStatusField.PENDING ):
            raise RequestError("Qual Request in Wrong State to Approve", 21)

        # First check if there is a qualification grant for this
        # worker with these parameters, if so we will update it

        try:
            grant = QualificationGrant.objects.get(
                worker = req.worker,
                qualification = req.qualification,
                )
            grant.value = value
            grant.active = True
        except QualificationGrant.DoesNotExist:
            grant = QualificationGrant.objects.create(
                worker = req.worker,
                qualification = req.qualification,
                value = value
                )

        grant.save()

        req.state = ReqQualStatusField.APPROVED
        req.save()

        return({})



    def ListReviewPolicyResultsForHIT(self, **kwargs):
        raise NotImplementedError("Review Policies Are Not Implemented Yet")

    def ListHITsForQualificationType(self, **kwargs):
        pass
